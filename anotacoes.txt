
instalacao do pip mac

curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

python3 get-pip.py

Linux

sudo apt install python3-pip


instalar o virtualenv

pip install virtualenv

-----
entrei na pasta do projeto

cd ~/Meu Drive/Cursos/Django/Django-templates-boas-praticas
cria o nosso ambiente de trabalho

virtualenv venv 
source venv/bin/activate

para desativar - deactivate

instalando o Django
pip3 install django


atualizando o pip

pip install --upgrade pip


- - - - - - - - - - - - - - - - - - - - - - - - - 

venv: É o ambiente virtual “padrão” do Python e sua grande vantagem é já vir instalado como um módulo na linguagem a partir da versão 3.3. Se trata de um subset (parte menor) da ferramenta virtualenv.
Virtualenv: É uma ferramenta feita especificamente para a criação de ambientes virtuais e precede a criação da venv, sendo um superset (parte maior) dela. Algumas de sua principais vantagens sobre a venv são:
Maior velocidade, graças ao método app-data seed;
Pode criar ambientes virtuais para versões arbitrárias do Python instaladas na máquina;
Pode ser atualizado utilizando a ferramenta pip;
Possui uma Programmatic API, capaz de descrever um ambiente virtual sem criá-lo.
Conda: É uma alternativa não apenas às ferramentas de ambiente virtuais já citadas, mas ao instalador de pacotes pip também. Possui um escopo mais centrado na área de ciência de dados e possui a capacidade de instalar pacotes fora do ecossistema do Python.
Virtualenvwrapper: É uma extensão do projeto Virtualenv que torna a criação, deleção e gerenciamento geral dos ambientes virtuais mais fácil. Uma grande vantagem de sua utilização é a organização de todos os ambientes virtuais utilizados em um só lugar, além de facilitar os comandos de CLI.
Poetry: É uma ferramenta para gerenciamento de dependências e pacotes do Python. Através do Poetry é possível declarar quais pacotes um projeto necessita para funcionar, de forma parecida ao requirements.txt, porém, de forma determinística.

vamos criar um projeot django

django-admin startproject setup .


rode o servidor pela primeira vez


python3 manage.py runserver
- - - - - - - - - - - - - - - - - - - - - - - - - 

alterando o timezome e a lingua principal, vamos entrar em ./setup/settings.py 

vamos descer e encontar o timezome e UTC 

---
LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'
---

vamos alterar para 
 ---
LANGUAGE_CODE = 'pt-br'

TIME_ZONE = 'America/Sao_Paulo'
 ---

- - - - - - - - - - - - - - - - - - - - - - - - - 

Variaveis de ambiente no Django 

para importar o nosso sistema para o git nao podemos enviar a nossa chave SECRET_KEY por motivos de seguranca
vamos colocar essa chave dentro de uma variavel de ambiente, para isso vamos instalar o pacote de Variaveis


pip3 install python-dotenv

pip3 freeze > requirements.txt 

vamos pegar nossa key dentro do ./setup/settings 
no nosso caso é o :
SECRET_KEY = 'django-insecure-$1t9w%++7%tntr2qkd(eig_99in6e*#lc5+%yrfgmlrdx9as(c'

dentro do arquivo que criamos o .env vamos criar a nossa variavel mas sem as aspas 

SECRET_KEY = django-insecure-$1t9w%++7%tntr2qkd(eig_99in6e*#lc5+%yrfgmlrdx9as(c


dentro do ./setup/settings.py vamos importa o os e o vemv
from pathlib import Path, os
from dotenv import load_dotenv
load_dotenv()

e vamos colocar a nossa variavel de ambiente

SECRET_KEY = str(os.getenv('SECRET_KEY'))

---
as linhas que alteramos foram: 

from pathlib import Path, os
from dotenv import load_dotenv
load_dotenv()

SECRET_KEY = str(os.getenv('SECRET_KEY'))
---

vamos upar nosso projeto para o git, mas antes vamos criar o nosso gitignore

no site: https://www.toptal.com/developers/gitignore/

tem uma lista de arquivos que nao devemos upar para o github

vamos procurar no que estamos codando e vamos copiar e colar no nosso projetp

no nosso casso foi o Django

e vamos startar o nosso git

git init

git add .

git commit -m "projeto space"

e vamos no nosso git e pegaremos o end

git remote add github git@github.com:SrPortugal/space.git # eu mudo o origin para github

- - - - - - - - - - - - - - - - - - - - - - - - - 


Aula 3 

os comandos do manager.py disponivel 

python manage.py help 

tem um comando startapp que sao pedacinhos do nosso projeto que compoem o django 

vamos criar o nosso primeiro app e chamar ele de galeria

python3 manage.py startapp galeria

agora vamos falar para o Djando que o novo app que instalamos participa do projeto

dentro do ./setup/settings.py vamos procurar o INSTALLED_APPS  e add o nosso novo app 

e ficou assim: 

--
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'galeria',
]
---

dentro de ./galeria/views.py vamos ajustar o nosso html para aparecer algo na nossa pq
vamos configurar e importar o django.http 
e ficou assim: 

---
from django.shortcuts import render
from django.http import HttpResponse

def index(request):
    return HttpResponse('<h1>Space</h1>')
---


e vamos ajustar a nossa rota no arquivo ./setup/urls.py 

dentro do urls.py 
---
from django.contrib import admin
from django.urls import path
from galeria.views import index

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index),
]
--- 

- - - - - - - - - - - - - - - - - - - - - - - - - 
Isolando as URLS, cada app vai controlar as suas rotas


para nao ter varias rotas dentro do setup principal vamos faz jump para q cada app controle a sua propria rota

de dentro do ./setup/urls.py vamos retirar o que importamos
 e add um include
o cod vai ficar assim:

---
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('galeria.urls')),
]
---

e dentro do nosso app ./galeria/urls.py vamos ajustar o arquivo

---
from django.urls import path
from galeria.views import index

urlpatterns = [
    path('', index),
]
---

e start o projeto

python3 manage.py runserver 


#### Templates #######

vamos falar para o Django onde vai ficar todo os templates que iremos utilizar na nossa estrutura

no arquivo ./setup/settings.py vamos procurar por TEMPLATES 
e vamos ajustar o redirecionamento

antes o codigo estava assim:

'DIRS': [],

e vamos alterar para:

'DIRS': [os.path.join(BASE_DIR, 'templates')],

vamos criar a pasta template e add um index.html dentro dele

e vamos ajustar o nosso render no ./galeria/views.py 
vou reitar o index, pq nao iremos usar mais 

e o views.py ficará assim:

--- 
from django.shortcuts import render

def index(request):
    return render(request, 'index.html')
---



- - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Aula 4

baixa o arquivo do git 
https://github.com/alura-cursos/alura_space/tree/projeto_front

para deixar o nosso codigo um pouco mais organizado, dentro do templates vamos criar uma pasta referente ao nosso app 
colocar o nosso index dentro da pasta que criamo. vamos abrir o index do projeto que baixarmos, copiar todos o conteudo e colocar dentro do nosso index na pasta ./templates/galeria/

com essa mudanca a nossa pagina vai dar erro temos ajustar o nosso viwes 
o cod vai ficar assim:

---
from django.shortcuts import render

def index(request):
    return render(request, 'galeria/index.html')
---

agora temos que ajustar o style


--------------

Arquivos staticos 

dentro do settings vamos criar o STATICFILES_DIRS = [], vamos fazer isso depois do STATIC_URL = 'statis/'

STATIC_DIRS = [
    os.path.join(BASE_DIR, 'setup/static')
]
e temos que indicar onde é o local ondo o python vai fazer o seu local dos arquivos staticos

STATIC_ROOT = os.path.join(BASE_DIR, 'static')

e dentro da pasta setup vamos criar uma pasta chamado static e dentro dela vamos add as pastas assets e styles que estavao no projeto

e vamos rodar o comando para ele indexar os arquivos staticos

python3 manage.py collectstatic

ele vai criar uma pasta chamado static onde staram disponivel os nosso arquivos staticos

agora temos que fazer para o nosso index que existe arquivos staticos e onde ele pode buscar 

no topo da pagina vamos add o comando
{% load static %}

e no link o style.css vamos ajustar para que possa buscar na nossa pg 

<link rel="stylesheet" href="{% static '/styles/style.css' %}">



----

1) Criamos uma página chamada templatesno diretório raiz do nosso projeto;

2) Dentro da pasta templates, vamos criar um diretório para cada app que temos. Sendo assim, criamos um diretório chamado galeria;

3) Criamos um arquivo chamado index.html dentro do diretório galeria. Ele será a página principal do site;

4) Inserimos no arquivo index.html o código disponibilizado nesta página;

5) Indicamos no arquivo settings.py no diretório setup que os templates do projeto devem ser utilizados através do diretório templates;

….
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
….

6) Alteramos o arquivo views.py do app galeria para considerar essa mudança;

from django.shortcuts import render

def index(request):
    return render(request, ‘galeria/index.html’)
    
7) Incluímos os diretórios de arquivos estáticos styles e assets, que podem ser baixados neste link, dentro do diretório static presente no diretório setup;

8) Indicamos no arquivo settings.py no diretório setup que os arquivos estáticos do projeto devem ser utilizados através do diretório static;

….

STATIC_URL = 'static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'setup/static')
]

STATIC_ROOT = os.path.join(BASE_DIR, 'static')
….

9) Rodamos o seguinte comando para fazer o django reconhecer os arquivos estáticos do projeto;

python manage.py collectstatic

10) Dentro do arquivo index.html inserimos a seguinte linha de código em Python que indicará que a página deve carregar arquivos estáticos;

{% load static %}
….

11) Mudamos a referência dos arquivos estáticos dentro do arquivo index.html para comunicar a localização dos arquivos estáticos através de código python;

{% load static %}
<!DOCTYPE html>
<html lang="pt-br">

<head>
    ….
    <link rel="stylesheet" href="{% static '/styles/style.css' %}">
</head>


Agora temos uma página na web com um estilo bem mais bonito! Porém, algumas imagens ainda não estão sendo carregadas no site.

Então é com você! Ao decorrer da aula foi explicada uma maneira de fazer a página index.html se comunicar com as imagens, utilizando código python dentro do HTML.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Aula 5

1) Vamos implementar o método DRY (Don't Repeat Yourself - Não se repita) criando um arquivo chamado base.html dentro do diretório galeria em templates;

2) Inserimos no arquivo base.html os trechos de código que se repetem em index.html e imagem.html;

3) Também inserimos no meio do arquivo base.html um indicativo de onde deve ser inserido o bloco de conteúdo que se diferencia em index.html e imagem.html;

{% load static %}
<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alura Space</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static '/styles/style.css' %}">
</head>

<body>
    {% block content %}{% endblock %}
</body>

</html>

4) Colocamos no início dos arquivos index.html e imagem.html um código Python que indica a importação do código em base.html, bem como, o início e o final do bloco de conteúdo de cada uma;

{% extends 'galeria/base.html' %}
{% load static %}
{% block content %}

....

{% endblock %}

5) Melhoramos ainda mais a prática do DRY! Criamos um novo diretório dentro de templates/galeria chamado partials;

6) Dentro desse novo diretório partials, criamos um novo arquivo chamado _footer.html;

7) Inserimos dentro de _footer.html o código de imagem.html e index.html correspondente;

{% load static %}
<footer class="rodape">
    <div class="rodape__icones">
        <a href="https://twitter.com/AluraOnline" target=”_blank” >
            <img src="{% static '/assets/ícones/1x/twitter.png' %}" alt="ícone twitter">
        </a>
        <a href="https://www.instagram.com/aluraonline/" target=”_blank” >
            <img src="{% static '/assets/ícones/1x/instagram.png' %}" alt="ícone instagram">
        </a>
    </div>
    <p class="rodape__texto">Desenvolvido por Alura</p>
</footer>
8) Excluímos o código correspondente ao footer em imagem.html e index.html;

9) Adicionamos em `base.html um novo "bloco de código";

{% load static %}
<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alura Space</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static '/styles/style.css' %}">
</head>

<body>
    {% block content %}{% endblock %}
    {% include 'galeria/partials/_footer.html' %}
</body>

</html>
Então temos um código mais atualizado em boas práticas de desenvolvimento. Porém, ainda podemos aplicar ainda mais a prática DRY.

Agora é com você! Ao decorrer da aula, foi mencionado um trecho de código em index.html e imagem.html que pode ser otimizado criando uma partial.


